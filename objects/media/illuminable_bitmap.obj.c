/*
 * miranda
 * Copyright (C) 2018 Andrea Nardinocchi (andrea@nardinan.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#include "illuminable_bitmap.obj.h"
struct s_illuminable_bitmap_attributes *p_illuminable_bitmap_alloc(struct s_object *self, struct s_object *stream, struct s_object *environment) {
  struct s_illuminable_bitmap_attributes *result = d_prepare(self, illuminable_bitmap);
  f_bitmap_new(self, stream, environment); /* inherit */
  return result;
}
struct s_object *f_illuminable_bitmap_new(struct s_object *self, struct s_object *stream, struct s_object *environment) {
  struct s_illuminable_bitmap_attributes *attributes = p_illuminable_bitmap_alloc(self, stream, environment);
  unsigned int index;
  attributes->main_axis = e_illuminable_bitmap_axis_x;
  for (index = 0; index < e_illuminable_bitmap_side_NULL; ++index)
    attributes->drawable_mask[index] = NULL;
  return self;
}
d_define_method(illuminable_bitmap, set_light_mask)(struct s_object *self, struct s_object *drawable_mask, enum e_illuminable_bitmap_sides side) {
  d_using(illuminable_bitmap);
  double mask_width, mask_height, image_width, image_height;
  if (illuminable_bitmap_attributes->drawable_mask[side])
    d_delete(illuminable_bitmap_attributes->drawable_mask[side]);
  illuminable_bitmap_attributes->drawable_mask[side] = d_retain(drawable_mask);
  d_call(illuminable_bitmap_attributes->drawable_mask[side], m_drawable_set_blend, e_drawable_blend_add);
  d_call(illuminable_bitmap_attributes->drawable_mask[side], m_drawable_get_dimension, &mask_width, &mask_height);
  d_call(self, m_drawable_get_dimension, &image_width, &image_height);
  d_assert((image_width == mask_width));
  d_assert((image_height == mask_height));
  return self;
}
d_define_method(illuminable_bitmap, set_lights)(struct s_object *self, struct s_object *lights) {
  d_using(illuminable_bitmap);
  if (illuminable_bitmap_attributes->lights)
    d_delete(illuminable_bitmap_attributes->lights);
  illuminable_bitmap_attributes->lights = d_retain(lights);
  return self;
}
d_define_method(illuminable_bitmap, set_main_axis)(struct s_object *self, enum e_illuminable_bitmap_axis main_axis) {
  d_using(illuminable_bitmap);
  illuminable_bitmap_attributes->main_axis = main_axis;
  return self;
}
d_define_method_override(illuminable_bitmap, draw)(struct s_object *self, struct s_object *environment) {
  d_using(illuminable_bitmap);
  struct s_environment_attributes *environment_attributes = d_cast(environment, environment);
  struct s_drawable_attributes *drawable_attributes = d_cast(self, drawable);
  struct s_lights_emitter_description *lights_emitter;
  struct s_list affected_lights;
  struct s_object *result = d_call_owner(self, bitmap, m_drawable_draw, environment); /* recall the father's draw method */
  double image_x, image_y, image_center_x, image_center_y, image_principal_point_x, image_principal_point_y, new_x, new_y,
    radians_rotation = -(drawable_attributes->angle * d_math_radians_conversion), radians_incident, cosine = cos(radians_rotation),
    sine = sin(radians_rotation), light_normalized_percentage[e_illuminable_bitmap_side_NULL], light_final_mask[e_illuminable_bitmap_side_NULL], local_factor,
    center_factor, center_factor_reduction;
  unsigned int index_side;
  if (illuminable_bitmap_attributes->lights) {
    memset(&(affected_lights), 0, sizeof(s_list));
    for (index_side = 0; index_side < e_illuminable_bitmap_side_NULL; ++index_side)
      light_final_mask[index_side] = 0;
    d_call(self, m_drawable_get_scaled_position, &image_x, &image_y);
    d_call(self, m_drawable_get_scaled_center, &image_center_x, &image_center_y);
    d_call(self, m_drawable_get_scaled_principal_point, &image_principal_point_x, &image_principal_point_y);
    d_call(illuminable_bitmap_attributes->lights, m_lights_get_affecting_lights, self, &(affected_lights), environment);
    d_foreach(&(affected_lights), lights_emitter, struct s_lights_emitter_description) {
      for (index_side = 0; index_side < e_illuminable_bitmap_side_NULL; ++index_side)
        light_normalized_percentage[index_side] = 0;
      /* we need to re-calculate the coordinates of the light in respect of the angle generated by this image */
      new_x = lights_emitter->position_x - (image_x + image_center_x);
      new_y = lights_emitter->position_y - (image_y + image_center_y);
      lights_emitter->position_x = (new_x * cosine) - (new_y * sine) + (image_x + image_center_x);
      lights_emitter->position_y = (new_x * sine) + (new_y * cosine) + (image_y + image_center_y);
      radians_incident = fmod(atan2(lights_emitter->position_y - image_principal_point_y, lights_emitter->position_x - image_principal_point_x), d_math_two_pi);
      /* we need to convert it to a positive angle */
      if (radians_incident < 0)
        radians_incident = d_math_two_pi + radians_incident;
      center_factor_reduction = 0.0;
      switch (illuminable_bitmap_attributes->main_axis) {
        case e_illuminable_bitmap_axis_x:
          center_factor = 1.0 - (fabs(lights_emitter->position_x - image_principal_point_x)/((image_principal_point_x + lights_emitter->radius) - image_x));
          if ((intptr_t)d_call(&(drawable_attributes->square_collision_box), m_square_inside_coordinates, lights_emitter->position_x,
                               lights_emitter->position_y))
            center_factor_reduction = 1.0 - (fabs(lights_emitter->position_x - image_principal_point_x)/(image_principal_point_x - image_x));
          break;
        case e_illuminable_bitmap_axis_y:
          center_factor =  1.0 - (fabs(lights_emitter->position_y - image_principal_point_y)/((image_principal_point_y + lights_emitter->radius) - image_y));
          if ((intptr_t)d_call(&(drawable_attributes->square_collision_box), m_square_inside_coordinates, lights_emitter->position_x,
                               lights_emitter->position_y))
            center_factor_reduction = 1.0 - (fabs(lights_emitter->position_y - image_principal_point_y)/(image_principal_point_y - image_y));
          break;
      }
      light_normalized_percentage[e_illuminable_bitmap_side_front] = center_factor;
      if ((radians_incident >= 0) && (radians_incident < d_math_half_pi)) {
        light_normalized_percentage[e_illuminable_bitmap_side_bottom] = (radians_incident / d_math_half_pi) * (1.0 - center_factor_reduction);
        light_normalized_percentage[e_illuminable_bitmap_side_right] = (1.0 - (radians_incident / d_math_half_pi)) * (1.0 - center_factor_reduction);
      } else if ((radians_incident >= d_math_half_pi) && (radians_incident < d_math_pi)) {
        light_normalized_percentage[e_illuminable_bitmap_side_left] = ((radians_incident - d_math_half_pi) / d_math_half_pi) * (1.0 - center_factor_reduction);
        light_normalized_percentage[e_illuminable_bitmap_side_bottom] = (1.0 - ((radians_incident - d_math_half_pi) / d_math_half_pi)) *
                                                                        (1.0 - center_factor_reduction);
      } else if ((radians_incident >= d_math_pi) && (radians_incident < (d_math_pi + d_math_half_pi))) {
        light_normalized_percentage[e_illuminable_bitmap_side_top] = ((radians_incident - d_math_pi) / d_math_half_pi) * (1.0 - center_factor_reduction);
        light_normalized_percentage[e_illuminable_bitmap_side_left] = (1.0 - ((radians_incident - d_math_pi) / d_math_half_pi)) *
                                                                      (1.0 - center_factor_reduction);
      } else if ((radians_incident >= (d_math_pi + d_math_half_pi)) && (radians_incident < d_math_two_pi)) {
        light_normalized_percentage[e_illuminable_bitmap_side_right] = ((radians_incident - (d_math_pi + d_math_half_pi)) / d_math_half_pi) *
                                                                       (1.0 - center_factor_reduction);
        light_normalized_percentage[e_illuminable_bitmap_side_top] = (1.0 - ((radians_incident - (d_math_pi + d_math_half_pi)) / d_math_half_pi)) *
                                                                           (1.0 - center_factor_reduction);
      }
      for (index_side = 0; index_side < e_illuminable_bitmap_side_NULL; ++index_side)
        if ((local_factor = (light_normalized_percentage[index_side] *
                             (((lights_emitter->radius - lights_emitter->distance) / lights_emitter->radius) * 255.0))) > 0) {
          /* now we have a factor that is proportional with the angle, with the distance and with the radius of the light. What we should do is to normalized
           * that value using the intensity and the penetration of the light into the  */
          if ((light_final_mask[index_side] += local_factor) > 255.0)
            light_final_mask[index_side] = 255.0;
        }
    }
    for (index_side = 0; index_side < e_illuminable_bitmap_side_NULL; ++index_side) {
      if ((light_final_mask[index_side] > 0) && (illuminable_bitmap_attributes->drawable_mask[index_side])) {
        /* we don't need to check the visibility because, if we are in this function, means that the visibility of the object has been already confirmed by the
         * called */
        d_call(illuminable_bitmap_attributes->drawable_mask[index_side], m_drawable_set_maskRGB, (unsigned int)light_final_mask[index_side],
               (unsigned int)light_final_mask[index_side], (unsigned int)light_final_mask[index_side]);
        while (((intptr_t)d_call(illuminable_bitmap_attributes->drawable_mask[index_side], m_drawable_draw, environment)) == d_drawable_return_continue);
      }
    }
    /* clean the content */
    while ((lights_emitter = (struct s_lights_emitter_description *)(affected_lights.head))) {
      f_list_delete(&(affected_lights), (struct s_list_node *)lights_emitter);
      d_free(lights_emitter);
    }
  }
  return result;
}
d_define_method_override(illuminable_bitmap, normalize_scale)(struct s_object *self, double reference_w, double reference_h, double offset_x, double offset_y,
                                                              double focus_x, double focus_y, double current_w, double current_h, double zoom) {
  d_using(illuminable_bitmap);
  struct s_drawable_attributes *drawable_core_attributes = d_cast(self, drawable), *drawable_other_attributes;
  struct s_object *result = d_call_owner(self, drawable, m_drawable_normalize_scale, reference_w, reference_h, offset_x, offset_y, focus_x, focus_y, current_w,
                                         current_h, zoom);
  int index_side;
  for (index_side = 0; index_side < e_illuminable_bitmap_side_NULL; ++index_side)
    if (illuminable_bitmap_attributes->drawable_mask[index_side]) {
      d_assert((drawable_other_attributes = d_cast(illuminable_bitmap_attributes->drawable_mask[index_side], drawable)));
      d_call(&(drawable_other_attributes->point_normalized_destination), m_point_set_point, &(drawable_core_attributes->point_normalized_destination));
      d_call(&(drawable_other_attributes->point_normalized_dimension), m_point_set_point, &(drawable_core_attributes->point_normalized_dimension));
      d_call(&(drawable_other_attributes->point_normalized_center), m_point_set_point, &(drawable_core_attributes->point_normalized_center));
      d_call(&(drawable_core_attributes->square_collision_box), m_square_set_square, &(drawable_core_attributes->square_collision_box));
    }
  return result;
}
d_define_method_override(illuminable_bitmap, keep_scale)(struct s_object *self, double current_w, double current_h) {
  d_using(illuminable_bitmap);
  struct s_drawable_attributes *drawable_core_attributes = d_cast(self, drawable), *drawable_other_attributes;
  struct s_object *result = d_call_owner(self, drawable, m_drawable_keep_scale, current_w, current_h);
  int index_side;
  for (index_side = 0; index_side < e_illuminable_bitmap_side_NULL; ++index_side)
    if (illuminable_bitmap_attributes->drawable_mask[index_side]) {
      d_assert((drawable_other_attributes = d_cast(illuminable_bitmap_attributes->drawable_mask[index_side], drawable)));
      d_call(&(drawable_other_attributes->point_normalized_destination), m_point_set_point, &(drawable_core_attributes->point_normalized_destination));
      d_call(&(drawable_other_attributes->point_normalized_dimension), m_point_set_point, &(drawable_core_attributes->point_normalized_dimension));
      d_call(&(drawable_other_attributes->point_normalized_center), m_point_set_point, &(drawable_core_attributes->point_normalized_center));
      d_call(&(drawable_core_attributes->square_collision_box), m_square_set_square, &(drawable_core_attributes->square_collision_box));
    }
  return result;
}
d_declare_method(illuminable_bitmap, delete)(struct s_object *self, struct s_illuminable_bitmap_attributes *attributes) {
  unsigned int index;
  for (index = 0; index < e_illuminable_bitmap_side_NULL; ++index) {
    if (attributes->drawable_mask[index]) {
      d_delete(attributes->drawable_mask[index]);
      attributes->drawable_mask[index] = NULL;
    }
  }
  return NULL;
}
d_define_class(illuminable_bitmap) {d_hook_method(illuminable_bitmap, e_flag_public, set_light_mask),
                                    d_hook_method(illuminable_bitmap, e_flag_public, set_lights),
                                    d_hook_method(illuminable_bitmap, e_flag_public, set_main_axis),
                                    d_hook_method_override(illuminable_bitmap, e_flag_public, drawable, draw),
                                    d_hook_method_override(illuminable_bitmap, e_flag_public, drawable, normalize_scale),
                                    d_hook_method_override(illuminable_bitmap, e_flag_public, drawable, keep_scale),
                                    d_hook_delete(illuminable_bitmap),
                                    d_hook_method_tail};